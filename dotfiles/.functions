#!/usr/bin/env bash

# List directory contents with cd
function cd() { builtin cd "$@" && ls; }

# Create a new directory and enter it
function mkcd() { mkdir -p "$@" && cd "$_"; }

# Go up N directories
function up() {
  str=""
  count=0
  while [ "$count" -lt "$1" ]; do
    str=$str"../"
    let count=count+1
  done
  cd $str
}

# Determine size of a file or total size of a directory
function fs() {
  if du -b /dev/null > /dev/null 2>&1; then
    local arg=-sbh
  else
    local arg=-sh
  fi
  if [[ -n "$@" ]]; then
    du $arg -- "$@"
  else
    du $arg .[^.]* ./*
  fi
}

# Find and Replace: findreplace searchText replacementText
function findreplace() { ack "$1" -la --print0 | xargs -0 -n 1 sed -i "s/$1/$2/"; }

# Opens any file in MacOS Quicklook Preview
function ql() { qlmanage -p "$*" >& /dev/null; }

# Zip the directory
function zd() { zip -r "$1".zip "$1"; }

# 7zip the directory
function 7zd() { 7z a "$1" "$1"/*; }

# Extract most known archives with one command
function extract() {
  if [ -f $1 ]; then
    case $1 in
      *.tar.bz2) tar xvjf $1                                   ;;
      *.tar.gz)  tar xvzf $1                                   ;;
      *.tar.xz)  tar xvJf $1                                   ;;
      *.lzma)    unlzma $1                                     ;;
      *.bz2)     bunzip2 $1                                    ;;
      *.rar)     unrar x -ad $1                                ;;
      *.gz)      gunzip $1                                     ;;
      *.tar)     tar xvf $1                                    ;;
      *.tbz2)    tar xvjf $1                                   ;;
      *.tgz)     tar xvzf $1                                   ;;
      *.zip)     unzip $1                                      ;;
      *.Z)       uncompress $1                                 ;;
      *.7z)      7z x $1                                       ;;
      *.xz)      unxz $1                                       ;;
      *.exe)     cabextract $1                                 ;;
      *)         echo "extract: '$1' - unknown archive method" ;;
    esac
  else
    echo "$1 - file does not exist"
  fi
}

# to ascii
function decode() {
  if   [[ $1 = 'base64' ]]; then shift 1; echo -n "$@" | base64 --decode
  elif [[ $1 = 'binary' ]]; then shift 1; echo -n "$@" | perl -lpe '$_=pack"B*",$_'
  elif [[ $1 = 'hex'    ]]; then shift 1; echo -n "0x$@" | xxd -r
  fi
}

# from ascii
function encode() {
  if   [[ $1 = 'base64' ]]; then shift 1; echo -n "$@" | openssl base64
  elif [[ $1 = 'binary' ]]; then shift 1; echo -n "$@" | perl -lpe '$_=unpack"B*"'
  elif [[ $1 = 'hex'    ]]; then shift 1; echo -n "$@" | xxd -p
  elif [[ $1 = 'md5'    ]]; then shift 1; echo -n "$@" | openssl md5
  elif [[ $1 = 'sha1'   ]]; then shift 1; echo -n "$@" | openssl sha1
  fi
}

# ss: convert spreadsheets to different formats (ex. xml, xls, xlsx)
# ss xlsx xml
function ss() { /Applications/LibreOffice.app/Contents/MacOS/soffice --convert-to $2 *.$1 --headless; }

#==============================================================================#
# Media: images, audio, video
#==============================================================================#

# resize: optimal settings for resizing images
# parameters - size (width in pixels, height is automatic), file, outputdir
# resize 300 "file.ext" outputdir/
function resize() { mogrify -path $3 -resize $1 -quality 85 -density 72 -strip $2; }

# crush: resize in batch form
# parameters: size (width in pixels, height is automatic), outputdir
# crush 300 out
function crush() { for f in "$(pwd)/*" ; do resize $1 "${f}" $2/; done }

# dimensions: get the dimensions of an image or directory of images
# parameters: file(s)
# dimensions file.jpg
# dimensions *
function dimensions() { identify -ping -format '%w\x%h\n' $@; }
function dimensions_json() { dimensions=$(identify -ping -format '{\n  "filename": "%f",\n  "width": "%w",\n  "height": "%h"\n},\n' $@); echo ${dimensions::-1}; }
#vdimensions: get the dimensions of a video
function vdimensions() { ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 $1; }

# mget: Download music with `youtube-dl`
function mget() { youtube-dl --extract-audio --audio-format mp3 -l "$1"; }

# ringtone: convert mp3 to m4r and change the length to 30 seconds
function ringtone() { ffmpeg -i "$1" -t 30 -c:a aac -f ipod -b:a 96k "$(basename "$1" .mp3).m4r"; }

# codecs: return video and audio codecs
function codecs() { ffprobe "$1" 2>&1 >/dev/null |grep Stream.*Video | sed -e 's/.*Video: //' -e 's/[, ].*//'; ffprobe "$1" 2>&1 >/dev/null |grep Stream.*Audio | sed -e 's/.*Audio: //' -e 's/[, ].*//'; }

# video_encode:
# parameters: filetype, video codec, audio codec
# `video_encode` remux all videos in the current directory to mp4
# `video_encode mkv libx265 aac` encode all videos to mkv with x265 and aac codecs
function video_encode() {
  filetype=${1:-mp4}
  video_codec=${2:-copy}
  audio_codec=${3:-copy}
  output=${4:-output}
  mkdir -p $output
  for i in *.mkv *.webm *.flv *.vob *.ogg *.ogv *.drc *gifv *.mng *.avi *.mov *.qt *.wmv *.yuv *.rm *.rmvb *.asf *.amv *.mp4 *.m4v *.mp *.m?v *.svi *.3gp *.flv *.f4v; do
    ffmpeg -i "$i" -map 0 -c:v $video_codec -c:a $audio_codec -nostats -loglevel 0 "./$output/${i/${i##*.}/$filetype}"
  done
}

# video_merge: `video_merge` combine all video files in the current directory into 1
function video_merge() { ffmpeg -f concat -i <(for f in *.mkv *.webm *.flv *.vob *.ogg *.ogv *.drc *gifv *.mng *.avi *.mov *.qt *.wmv *.yuv *.rm *.rmvb *.asf *.amv *.mp4 *.m4v *.mp *.m?v *.svi *.3gp *.flv *.f4v; do echo "file '$PWD/$f'"; done) -c copy -nostats -loglevel 0 "output.${1}"; }

# converts HH:MM:SS.sss to fractional seconds
timeToSeconds() (
  local hh=${1%%:*}
  local rest=${1#*:}
  local mm=${rest%%:*}
  local ss=${rest#*:}
  printf "%s" $(bc <<< "$hh * 60 * 60 + $mm * 60 + $ss")
)

# converts fractional seconds to HH:MM:SS.sss
secondsToTime() (
  local seconds=$1
  local hh=$(bc <<< "scale=0; $seconds / 3600")
  local remainder=$(bc <<< "$seconds % 3600")
  local mm=$(bc <<< "scale=0; $remainder / 60")
  local ss=$(bc <<< "$remainder % 60")
  printf "%02d:%02d:%06.3f" "$hh" "$mm" "$ss"
)

# finds the difference between two HH:MM:SS.sss times
timeDifference() (
  local t1sec=$(timeToSeconds "$1")
  local t2sec=$(timeToSeconds "$2")
  printf "%s" $(bc <<< "$t2sec - $t1sec")
)

# vget_range: https://www.youtube.com/watch?v=id 00:15:00 00:45:00
function vget_range() {
  if [[ $1 = 'range' ]]; then shift 1
    # variables
    vurl=$1
    startTime=$2
    endTime=$3
    title="${4:-video}"
    duration=$(($(timeDifference $startTime $endTime)/60)) # duration in seconds

    # start
    ffmpeg

    # URL
    # input file url
    -i $(youtube-dl -f 22 --get-url "$vurl")

    # Start Time
    # Seeks in this input file to position.
    # Note that in most formats it is not possible to seek exactly, so ffmpeg will seek to the closest seek point before position. When transcoding and -accurate_seek is enabled (the default), this extra segment between the seek point and position will be decoded and discarded. When doing stream copy or when -noaccurate_seek is used, it will be preserved.
    -ss $startTime

    # Duration
    # Limit the duration of data read from the input file.
    -t $duration

    # Frames Per Second
    # Set frame rate (Hz value, fraction or abbreviation).
    -r 30

    # Constant Rate Factor
    # The range of the CRF scale is 0–51, where 0 is lossless, 23 is the default, and 51 is worst quality possible.
    # A lower value generally leads to higher quality, and a subjectively sane range is 17–28. Consider 17 or 18 to be visually lossless or nearly so; it should look the same or nearly the same as the input but it isn't technically lossless.
    -crf 15.0

    # Video Codec
    -vcodec libx264

    # Audio Codec
    -acodec aac

    # Overwrite output files. (-y for yes, -n for no)
    -n

    # Output Dir
    "$title.mp4"
  fi
}

#==============================================================================#
# Maintenance
#==============================================================================#

# update: Get macOS Software Updates, update packages, and general cleanup
function update() {
  sama
  echo
  echo 'Symlinks'
  echo '================================================================================'
  echo
  echo 'Updating symlinks…'
  update_symlinks
  echo
  echo 'Dotfiles'
  echo '================================================================================'
  echo
  echo 'Updating dotfiles…'
  update_dotfiles --force
  echo
  echo 'MAS'
  echo '================================================================================'
  echo
  echo 'Updating mas apps…'
  mas upgrade
  echo
  echo 'Homebrew'
  echo '================================================================================'
  echo
  echo 'Updating brew packages…'
  brew update-reset > /dev/null; brew upgrade; brew missing; brew cask upgrade; brew cleanup; brew services cleanup
  echo
  echo 'NPM'
  echo '================================================================================'
  echo
  echo 'Updating npm modules…'
  npm update -g; npm cache clean --force
  echo
  echo 'PIP'
  echo '================================================================================'
  echo
  echo 'Updating python packages…'
  pip3 install --upgrade pip
  pip3 install -U $(pip freeze | cut -d '=' -f 1)
  echo
  echo 'Sublime Text'
  echo '================================================================================'
  echo
  echo 'Backing up Sublime Text settings…'
  cp ~/Library/Application\ Support/Sublime\ Text*/Packages/User/*.sublime-settings ~/prime/dotfiles/init/
  echo
  echo 'Git Repositories'
  echo '================================================================================'
  echo
  echo 'Updating git repos…'
  cd ~/Documents/Repos/ && update_repos; cd ~
  echo
  echo 'macOS'
  echo '================================================================================'
  echo
  echo 'Running macOS update…'
  softwareupdate -i -a
  echo
  echo 'Cleaning'
  echo '================================================================================'
  echo
  echo 'Deduping ssh known hosts…'
  cat ~/.ssh/known_hosts | uniq > ~/.ssh/known_hosts2; mv ~/.ssh/known_hosts2 ~/.ssh/known_hosts # add "| sort" to list in abc order
  echo 'Purge dead links from autojump…'
  j --purge
  echo 'Clear cache…'
  clearcache
  echo 'Clear clipboard…'
  clearclipboard
  echo 'Clear logs…'
  clearlogs
  echo 'Empty trash…'
  emptytrash
  echo
  echo 'Everything is up to date!'
}

function fget() { open https://github.com/search?q=extension%3Attf+extension%3Aotf+filename%3A%22$1%22&type=Code; }
