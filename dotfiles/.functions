#!/usr/bin/env bash

# List directory contents with cd
function cd() { builtin cd "$@" && ls; }

# Create a new directory and enter it
function mkcd() { mkdir -p "$@" && cd "$_"; }

# Opens any file in MacOS Quicklook Preview
function ql() { qlmanage -p "$*" >& /dev/null; }

# Zip the directory
function zd() { zip -r "$1".zip "$1"; }

# 7zip the directory
function 7zd() { 7z a "$1" "$1"/*; }

# Extract most known archives with one command
function extract() {
  if [ -f $1 ]; then
    case $1 in
      *.tar.bz2) tar xvjf $1                                   ;;
      *.tar.gz)  tar xvzf $1                                   ;;
      *.tar.xz)  tar xvJf $1                                   ;;
      *.lzma)    unlzma $1                                     ;;
      *.bz2)     bunzip2 $1                                    ;;
      *.rar)     unrar x -ad $1                                ;;
      *.gz)      gunzip $1                                     ;;
      *.tar)     tar xvf $1                                    ;;
      *.tbz2)    tar xvjf $1                                   ;;
      *.tgz)     tar xvzf $1                                   ;;
      *.zip)     unzip $1                                      ;;
      *.Z)       uncompress $1                                 ;;
      *.7z)      7z x $1                                       ;;
      *.xz)      unxz $1                                       ;;
      *.exe)     cabextract $1                                 ;;
      *)         echo "extract: '$1' - unknown archive method" ;;
    esac
  else
    echo "$1 - file does not exist"
  fi
}

function text() {
  # Colors
  case $1 in
    color)
      case $2 in
        black)   echo -e "\033[0;30m" ;;
        red)     echo -e "\033[0;31m" ;;
        green)   echo -e "\033[0;32m" ;;
        yellow)  echo -e "\033[0;33m" ;;
        blue)    echo -e "\033[0;34m" ;;
        magenta) echo -e "\033[0;35m" ;;
        cyan)    echo -e "\033[0;36m" ;;
        white)   echo -e "\033[0;37m" ;;
      esac
    ;;
    # Format
    bold)      tput bold ;;
    underline) tput smul ;;
    invert)    tput rev  ;;
    # Reset
    '') echo -e "\033[0m" ;;
  esac
}

# to ascii
function decode() {
  case $1 in
    base64) shift 1; echo -n "$@" | base64 --decode            ;;
    binary) shift 1; echo -n "$@" | perl -lpe '$_=pack"B*",$_' ;;
    hex)    shift 1; echo -n "0x$@" | xxd -r                   ;;
  esac
}

# from ascii
function encode() {
  case $1 in
    base64) shift 1; echo -n "$@" | openssl base64            ;;
    binary) shift 1; echo -n "$@" | perl -lpe '$_=unpack"B*"' ;;
    hex)    shift 1; echo -n "$@" | xxd -p                    ;;
    md5)    shift 1; echo -n "$@" | openssl md5               ;;
    sha1)   shift 1; echo -n "$@" | openssl sha1              ;;
  esac
}

# ss: convert spreadsheets to different formats (ex. xml, xls, xlsx)
# ss xlsx xml
function ss() { /Applications/LibreOffice.app/Contents/MacOS/soffice --convert-to $2 *.$1 --headless; }

#------------------------------------------------------------------------------#
# Media: images, audio, video
#------------------------------------------------------------------------------#

# resize: optimal settings for resizing images
# parameters - size (width in pixels, height is automatic), file, outputdir
# resize 300 "file.ext" outputdir/
function resize() { mogrify -path $3 -resize $1 -quality 85 -density 72 -strip $2; }

# crush: resize in batch form
# parameters: size (width in pixels, height is automatic), outputdir
# crush 300 out
function crush() { for f in "$(pwd)/*" ; do resize $1 "${f}" $2/; done }

# dimensions: get the dimensions of an image or directory of images
# parameters: file(s)
# dimensions file.jpg
# dimensions *
function dimensions() { identify -ping -format '%w\x%h\n' $@; }
function dimensions_json() { dimensions=$(identify -ping -format '{\n  "filename": "%f",\n  "width": "%w",\n  "height": "%h"\n},\n' $@); echo ${dimensions::-1}; }
#vdimensions: get the dimensions of a video
function vdimensions() { ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 $1; }

# mget: Download music with `youtube-dl`
function mget() { youtube-dl --extract-audio --audio-format mp3 -l "$1"; }

# ringtone: convert mp3 to m4r and change the length to 30 seconds
function ringtone() { ffmpeg -i "$1" -t 30 -c:a aac -f ipod -b:a 96k "$(basename "$1" .mp3).m4r"; }

# codecs: return video and audio codecs
function codecs() { ffprobe "$1" 2>&1 >/dev/null |grep Stream.*Video | sed -e 's/.*Video: //' -e 's/[, ].*//'; ffprobe "$1" 2>&1 >/dev/null |grep Stream.*Audio | sed -e 's/.*Audio: //' -e 's/[, ].*//'; }

# video_encode:
# parameters: filetype, video codec, audio codec
# `video_encode` remux all videos in the current directory to mp4
# `video_encode mkv libx265 aac` encode all videos to mkv with x265 and aac codecs
function video_encode() {
  filetype=${1:-mp4}
  video_codec=${2:-copy}
  audio_codec=${3:-copy}
  output=${4:-output}
  mkdir -p $output
  for i in *.mkv *.webm *.flv *.vob *.ogg *.ogv *.drc *gifv *.mng *.avi *.mov *.qt *.wmv *.yuv *.rm *.rmvb *.asf *.amv *.mp4 *.m4v *.mp *.m?v *.svi *.3gp *.flv *.f4v; do
    if [ -f "$i" ]; then
      if [ $1 = true ]
      then
        ffmpeg -i "$i" -map 0 -c:v $video_codec -c:a $audio_codec -y -nostats -loglevel 0 "./$output/${i/${i##*.}/$filetype}"
      else
        ffmpeg -i "$i" -c copy "./$output/${i/${i##*.}/$filetype}"
      fi
    fi
  done
}

# video_merge: `video_merge` combine all video files in the current directory into 1
function video_merge() { ffmpeg -f concat -i <(for f in *.mkv *.webm *.flv *.vob *.ogg *.ogv *.drc *gifv *.mng *.avi *.mov *.qt *.wmv *.yuv *.rm *.rmvb *.asf *.amv *.mp4 *.m4v *.mp *.m?v *.svi *.3gp *.flv *.f4v; do echo "file '$PWD/$f'"; done) -c copy -nostats -loglevel 0 "output.${1}"; }

# converts HH:MM:SS.sss to fractional seconds
timeToSeconds() (
  local hh=${1%%:*}
  local rest=${1#*:}
  local mm=${rest%%:*}
  local ss=${rest#*:}
  printf "%s" $(bc <<< "$hh * 60 * 60 + $mm * 60 + $ss")
)

# converts fractional seconds to HH:MM:SS.sss
secondsToTime() (
  local seconds=$1
  local hh=$(bc <<< "scale=0; $seconds / 3600")
  local remainder=$(bc <<< "$seconds % 3600")
  local mm=$(bc <<< "scale=0; $remainder / 60")
  local ss=$(bc <<< "$remainder % 60")
  printf "%02d:%02d:%06.3f" "$hh" "$mm" "$ss"
)

# finds the difference between two HH:MM:SS.sss times
timeDifference() (
  local t1sec=$(timeToSeconds "$1")
  local t2sec=$(timeToSeconds "$2")
  printf "%s" $(bc <<< "$t2sec - $t1sec")
)

# vget https://www.youtube.com/watch?v=id
# vget range https://www.youtube.com/watch?v=id 00:15:00 00:45:00
function vget() {
  if [[ $1 = 'range' ]]; then shift 1
    # variables
    vurl=$1
    startTime=$2
    endTime=$3
    title="${4:-video}"
    duration=$(($(timeDifference $startTime $endTime)/60)) # duration in seconds
    # start
    range=(
    ffmpeg
    # URL
    # input file url
    -i $(youtube-dl -f 22 --get-url $vurl)
    # Start Time
    # Seeks in this input file to position.
    # Note that in most formats it is not possible to seek exactly, so ffmpeg will seek to the closest seek point before position. When transcoding and -accurate_seek is enabled (the default), this extra segment between the seek point and position will be decoded and discarded. When doing stream copy or when -noaccurate_seek is used, it will be preserved.
    -ss $startTime
    # Duration
    # Limit the duration of data read from the input file.
    -t $duration
    # Frames Per Second
    # Set frame rate (Hz value, fraction or abbreviation).
    -r 30
    # Constant Rate Factor
    # The range of the CRF scale is 0–51, where 0 is lossless, 23 is the default, and 51 is worst quality possible.
    # A lower value generally leads to higher quality, and a subjectively sane range is 17–28. Consider 17 or 18 to be visually lossless or nearly so; it should look the same or nearly the same as the input but it isn't technically lossless.
    -crf 15.0
    # Video Codec
    -vcodec libx264
    # Audio Codec
    -acodec aac
    # Overwrite output files. (-y for yes, -n for no)
    -n
    # Output Dir
    $title.mp4
    )
    "${range[@]}"
  else
    # youtube-dl looking for an mp4 with the best video and audio
    youtube-dl -f 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/mp4' $1
  fi
}

#------------------------------------------------------------------------------#
# Maintenance
#------------------------------------------------------------------------------#

# update: Get macOS Software Updates, update packages, and general cleanup
# TODO: implement this? https://github.com/fwartner/mac-cleanup/blob/master/cleanup.sh
function update() {
  sama
  cd ~
  echo
  echo 'Symlinks'
  echo '--------------------------------------------------------------------------------'
  echo
  echo 'Updating symlinks…'
  update_symlinks
  echo
  echo 'Dotfiles'
  echo '--------------------------------------------------------------------------------'
  echo
  echo 'Updating dotfiles…'
  update_dotfiles --force
  echo
  echo 'MAS'
  echo '--------------------------------------------------------------------------------'
  echo
  echo 'Updating mas apps…'
  mas upgrade
  echo
  echo 'Homebrew'
  echo '--------------------------------------------------------------------------------'
  echo
  echo 'Updating brew packages…'
  brew upgrade; brew missing; brew cask upgrade; brew cleanup; brew services cleanup
  cd ~//packages/
  brew bundle dump --force --describe
  cd ~
  echo
  echo 'NPM'
  echo '--------------------------------------------------------------------------------'
  echo
  echo 'Updating npm modules…'
  npm update -g; npm cache clean --force
  echo
  echo 'PIP'
  echo '--------------------------------------------------------------------------------'
  echo
  echo 'Updating python packages…'
  pip3 install --upgrade pip
  pip3 install -U $(pip freeze | cut -d '=' -f 1)
  echo
  echo 'Sublime Text'
  echo '--------------------------------------------------------------------------------'
  echo
  echo 'Backing up Sublime Text settings…'
  cp ~/Library/Application\ Support/Sublime\ Text*/Packages/User/Package\ Control.sublime-settings ~//init/
  cp ~/Library/Application\ Support/Sublime\ Text*/Packages/User/Preferences.sublime-settings ~//init/
  echo
  echo 'Git Repositories'
  echo '--------------------------------------------------------------------------------'
  echo
  echo 'Updating git repos…'
  cd ~/Documents/Repos/ && update_repos; cd ~
  echo
  echo 'macOS'
  echo '--------------------------------------------------------------------------------'
  echo
  echo 'Running macOS update…'
  softwareupdate -i -a
  echo
  echo 'Cleaning'
  echo '--------------------------------------------------------------------------------'
  echo
  echo 'Deduping ssh known hosts…'
  cat ~/.ssh/known_hosts | uniq > ~/.ssh/known_hosts2; mv ~/.ssh/known_hosts2 ~/.ssh/known_hosts # add "| sort" to list in abc order
  echo 'Clear cache…'
  clearcache
  echo 'Clear clipboard…'
  clearclipboard
  echo 'Clear logs…'
  clearlogs
  echo 'Empty trash…'
  emptytrash
  echo
  echo 'Everything is up to date!'
}
